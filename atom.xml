<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[mackxu的博客]]></title>
  <subtitle><![CDATA[学而时习之不亦说乎]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://mackxu.github.io/"/>
  <updated>2015-08-19T02:24:14.000Z</updated>
  <id>http://mackxu.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[rem 在项目中的简单使用]]></title>
    <link href="http://mackxu.github.io/2015/08/18/rem-simple-use/"/>
    <id>http://mackxu.github.io/2015/08/18/rem-simple-use/</id>
    <published>2015-08-18T13:24:59.000Z</published>
    <updated>2015-08-19T02:24:14.000Z</updated>
    <content type="html"><![CDATA[<p>在项目中重度使用rem<br><a id="more"></a><br>名词解释，rem: root em<br>实用的页面范围: 1280x720、1920x1080、3840x2160</p>
<h2 id="设置html的font_size">设置html的font size</h2><p>rem是相对的长度单位。页面中的所有元素可以相对于根元素(html)设置任何大小。<br>对html使用媒介查询适配不同屏幕：</p>
<pre><code><span class="tag">html</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">66.666px</span></span></span>; }</span>
<span class="at_rule">@<span class="keyword">media</span> (min-width: <span class="number">1920px</span>) </span>{
    <span class="tag">html</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">100px</span></span></span>; }</span>
}
<span class="at_rule">@<span class="keyword">media</span> (min-width: <span class="number">3840px</span>) </span>{
    <span class="tag">html</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">200px</span></span></span>; }</span>
}
</code></pre><p>如果用在移动设备，上面的样式需要在页面head中设置：</p>
<pre><code>&lt;meta <span class="property">name</span>=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span> /&gt;
</code></pre><p>把设备1920w下的html样式设置为100px，是为了编写样式的方便，保持了和设计师提供的效果图一样的宽度(关于为什么设置100px，是个人习惯)。因此可以简单地把其他两个宽度的下的html的大小计算出来。</p>
<h2 id="提示">提示</h2><p>在rem适配中，难免会有小数点出现。不好的是有些android设备会忽略小数位。这种情况在动画时，缺点很明显。解决办法是，适配1280w，盒子的尺寸尽量设置能被3整除的数字。例如：</p>
<pre><code><span class="class">.album-item</span> <span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">2.91rem</span></span></span>;
}</span>
</code></pre><p>如果设置上面了的媒介查询代码，那么div.album-item的宽度在1920w下是291px, 1280w下是194px，同理3840w下是582px。</p>
<p>参看资料:<br><a href="http://www.w3cplus.com/css3/define-font-size-with-css3-rem" target="_blank" rel="external">http://www.w3cplus.com/css3/define-font-size-with-css3-rem</a><br><a href="http://isux.tencent.com/web-app-rem.html" target="_blank" rel="external">http://isux.tencent.com/web-app-rem.html</a><br><a href="http://www.html-js.com/article/2402" target="_blank" rel="external">http://www.html-js.com/article/2402</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在项目中重度使用rem<br>]]>
    
    </summary>
    
      <category term="css" scheme="http://mackxu.github.io/tags/css/"/>
    
      <category term="经验" scheme="http://mackxu.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[比较JS文件加载：async和DOM Script]]></title>
    <link href="http://mackxu.github.io/2015/01/13/async-script/"/>
    <id>http://mackxu.github.io/2015/01/13/async-script/</id>
    <published>2015-01-13T07:35:37.000Z</published>
    <updated>2014-08-29T11:14:07.000Z</updated>
    <content type="html"><![CDATA[<p>async与script动态加载都能使文件异步加载，本文叙述它们对页面渲染和load加载的影响方面。<br><a id="more"></a><br>目前我用demo.js作为执行文件操作.代码：</p>
<pre><code><span class="keyword">var</span> now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> +(<span class="keyword">new</span> <span class="built_in">Date</span>()); }
<span class="keyword">var</span> t_s = now();
<span class="keyword">while</span>(now() - t_s &lt; <span class="number">2000</span>) {  }
</code></pre><p>用sleep.php作为请求文件操作。代码：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
    sleep(<span class="number">3</span>);
    <span class="keyword">echo</span> <span class="string">'var bb'</span>;
<span class="preprocessor">?&gt;</span></span>
</code></pre><h2 id="1-_一般script标签加载">1. 一般script标签加载</h2><pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"demo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"sleep.php"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>在浏览器加载情况: <strong>图1-1. 下载阻塞DomReady</strong> <strong>图1-2. 执行阻塞DomReady</strong><br><img src="http://qnimg.qiniudn.com/140720/1-DOMReady.png" alt=""><strong>图1-1. 下载阻塞DomReady</strong></p>
<p><img src="http://qnimg.qiniudn.com/140720/2-DOMReady.png" alt="">  <strong>图1-2. 执行阻塞DomReady</strong></p>
<h2 id="2-_async属性">2. async属性</h2><p>async是html5中新增的属性，它的作用是能够异步下载脚本文件，不阻塞DOMReady。<br>每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况<br>支持async浏览器: Firefox 3.6+, IE 10+, Chrome 2+, Safari 5+, iOS 5+, Android 3+</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"demo.js"</span> <span class="attribute">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"sleep.php"</span> <span class="attribute">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>   
</code></pre><p>在浏览器中加载的情况：<br><img src="http://qnimg.qiniudn.com/140720/1-async.png" alt=""><strong>图2-1 异步下载 不阻塞DomReady 阻塞load事件</strong> </p>
<p><img src="http://qnimg.qiniudn.com/140720/2-async.png" alt=""><strong>图2-2 执行阻塞load事件</strong></p>
<p><img src="http://qnimg.qiniudn.com/140720/3-ie-async.png" alt=""><strong>图2-3 IE9不支持async属性下载阻塞DomReady</strong></p>
<h2 id="3-_DOM_Script动态加载">3. DOM Script动态加载</h2><p>文档对象模型（DOM）允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。<br>script元素与页面其他元素一样，可以非常容易地通过标准 DOM 函数创建：</p>
<pre><code><span class="keyword">var</span> loadScript = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>{
    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);
    s.type = <span class="string">'text/javascript'</span>;
    s.async = <span class="string">'true'</span>;
    s.src = url;
    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(s);    
}
<span class="comment">// 加载js文件脚本</span>
loadScript(<span class="string">'sleep.php'</span>);
loadScript(<span class="string">'demo.js'</span>);
</code></pre><p>在浏览器中加载的情况：<br><img src="http://qnimg.qiniudn.com/140720/1-script.png" alt=""><strong>图3-1 下载阻塞load事件</strong></p>
<p><img src="http://qnimg.qiniudn.com/140720/2-script.png" alt=""><strong>图3-2 执行阻塞load事件</strong></p>
<p><img src="http://qnimg.qiniudn.com/140720/3-ie-script.png" alt=""><strong>图3-3 IE9不阻塞load事件</strong></p>
<h2 id="小结">小结</h2><p>async和script动态加载在现代浏览器中加载的情况是一致的。前者使用简单，后在兼容性方面更好。<br>异步加载文件还有很多方法，ajax(会受到同源限制)、iFrame、img…</p>
<p>参考链接：<br><a href="http://ie.microsoft.com/TestDrive/Performance/AsyncScripts/Default.html" target="_blank" rel="external">http://ie.microsoft.com/TestDrive/Performance/AsyncScripts/Default.html</a><br><a href="http://ued.ctrip.com/blog/?p=3121" target="_blank" rel="external">http://ued.ctrip.com/blog/?p=3121</a><br><a href="http://blog.jobbole.com/47304/" target="_blank" rel="external">http://blog.jobbole.com/47304/</a><br><a href="http://www.infoq.com/cn/articles/browser-resource-loading-optimization" target="_blank" rel="external">http://www.infoq.com/cn/articles/browser-resource-loading-optimization</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>async与script动态加载都能使文件异步加载，本文叙述它们对页面渲染和load加载的影响方面。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[为图片添加半透明遮罩效果]]></title>
    <link href="http://mackxu.github.io/2014/09/04/image-overlay/"/>
    <id>http://mackxu.github.io/2014/09/04/image-overlay/</id>
    <published>2014-09-03T23:22:25.000Z</published>
    <updated>2014-09-06T11:05:34.000Z</updated>
    <content type="html"><![CDATA[<p>平时为图片添加半透明遮罩效果，我的做法如下：<br>利用标签i实现背景半透明遮罩。当鼠标hover时, 提高i的背景色透明度值<code>background-color: rgba(0, 0, 0, .6)</code></p>
<pre><code><span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"opacity-black-position"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"images/4601.jpg"</span> <span class="attribute">alt</span>=<span class="value">""</span>&gt;</span><span class="tag">&lt;<span class="title">i</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>为html结构添加如下css样式：</p>
<pre><code><span class="comment">/* 利用标签i实现背景半透明遮罩, 兼容性不好 */</span>
<span class="class">.opacity-black-position</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">460px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">460px</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; }</span>
<span class="class">.opacity-black-position</span> <span class="tag">i</span> <span class="rules">{ 
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>; 
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; 
    <span class="rule"><span class="attribute">transition</span>:<span class="value"> background-color .<span class="number">5s</span></span></span>;  
}</span>
<span class="class">.opacity-black-position</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover i { background-color: <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">6</span>)</span></span>; }
</code></pre><h2 id="利用opacity简单实现">利用opacity简单实现</h2><p>昨天看到京东商品图片上的半透明黑色遮罩，是这样实现的。当hover时设置a的透明度为0.4</p>
<pre><code>&lt;<span class="tag">p</span> class=<span class="string">"opacity-black"</span>&gt;&lt;<span class="tag">a</span> href=<span class="string">"#"</span>&gt;&lt;<span class="tag">img</span> src=<span class="string">"images/4601.jpg"</span> alt=<span class="string">""</span>&gt;&lt;/a&gt;&lt;/p&gt;
</code></pre><p>为html结构添加如下css样式:</p>
<pre><code><span class="class">.opacity-black</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">460px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">460px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#000</span></span></span>; }</span>
<span class="class">.opacity-black</span> <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">transition</span>:<span class="value"> opacity .<span class="number">5s</span></span></span>; <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">1</span></span></span>; }</span>
<span class="class">.opacity-black</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover { opacity: <span class="number">0.4</span></span></span>; }
</code></pre><p>通过降低自身a及子标签img的透明度来显示父辈容器的背景色, 达到的效果和上面是一样一样的。</p>
<p><strong>狠狠滴点这里(演示):</strong> <a href="http://codepen.io/mackxu/pen/mJtvh" target="_blank" rel="external">http://codepen.io/mackxu/pen/mJtvh</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>平时为图片添加半透明遮罩效果，我的做法如下：<br>利用标签i实现背景半透明遮罩。当鼠标hover时, 提高i的背景色透明度值<code>background-color: rgba(0, 0, 0, .6)</code></p>
<pre><code><span clas]]>
    </summary>
    
      <category term="css" scheme="http://mackxu.github.io/tags/css/"/>
    
      <category term="工作经验" scheme="http://mackxu.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[顺序表查找算法及其优化]]></title>
    <link href="http://mackxu.github.io/2014/09/01/sequential-search/"/>
    <id>http://mackxu.github.io/2014/09/01/sequential-search/</id>
    <published>2014-09-01T09:27:21.000Z</published>
    <updated>2014-09-06T11:01:22.000Z</updated>
    <content type="html"><![CDATA[<p>顺序查找算法实现如下:</p>
<pre><code>var arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]
    , sequentialSearch = function(arr, val) {
        var i = <span class="number">0</span>
            , len = arr.length;
        <span class="keyword">for</span> ( ; i &lt; len; i++) {             <span class="comment">// 比较一次</span>
            <span class="keyword">if</span> (arr[i] === val) {           <span class="comment">// 比较二次</span>
                <span class="keyword">return</span> i;
            }
        }
        <span class="keyword">return</span> i;                           <span class="comment">// 返回len,则说明查找失败</span>
    }
</code></pre><p>这里并不是足够完美, 因为每次循环时都需要对i是否越界, 即是否小于len做判断。事实上，还可以有更好的办法，设置一个哨兵, 就可以解决不需要每次让i与len做比较了。</p>
<h2 id="顺序表查找优化">顺序表查找优化</h2><pre><code><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]
    <span class="comment">// 有哨兵的顺序表查找</span>
    , sequentialSearchOpt = function(arr, <span class="function"><span class="keyword">val</span>) {</span>
        <span class="keyword">var</span> i = <span class="number">0</span>
            , arr = arr.slice(<span class="number">0</span>)            <span class="comment">// 保证函数内操作不影响外部的arr数组 </span>
            , len = arr.length;
        arr[len] = <span class="function"><span class="keyword">val</span>;</span>                     <span class="comment">// 设置arr[len]为关键字值作为哨兵</span>
        <span class="comment">// arr.push(val);</span>
        <span class="keyword">while</span> (arr[i] !== <span class="function"><span class="keyword">val</span>) {</span>            <span class="comment">// 比较一次</span>
            i++;
        }
        <span class="keyword">return</span> i;                           <span class="comment">// 返回len,则说明查找失败</span>
    }
</code></pre><p>如果arr[i]中有值等于val则返回i，否则一定会在循环结束处等于val, 此时返回len值。说明数组中没有关键字等于val,查找失败。</p>
<blockquote>
<p>在测试过程中, 发现因为由于对象是按地址传递的，在函数中改变数组<code>arr[len] = val</code>会影响到外部的数组，因此需要在函数内clone一份数组出来</p>
</blockquote>
<p>这种在查找方向的尽头设置‘哨兵’免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数较多时，效率提高很大，是非常好的编程技巧。</p>
<p><strong>参考：</strong> 大话数据结构 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>顺序查找算法实现如下:</p>
<pre><code>var arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span ]]>
    </summary>
    
      <category term="优化" scheme="http://mackxu.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法" scheme="http://mackxu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[google-analytics的使用 解析页面引入代码]]></title>
    <link href="http://mackxu.github.io/2014/08/22/analyticsjs/"/>
    <id>http://mackxu.github.io/2014/08/22/analyticsjs/</id>
    <published>2014-08-22T08:16:07.000Z</published>
    <updated>2015-08-19T01:54:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="代码整理和注释">代码整理和注释</h2><pre><code><span class="comment">// 创建ga()方法, 加载analytics.js文件</span>
<span class="comment">// a, m 作为形参，确保下面的执行不会修改外部的同名变量</span>
(function(<span class="keyword">win</span>, doc, o, <span class="keyword">g</span>, ga, a , <span class="keyword">m</span>){

    <span class="keyword">win</span>['GoogleAnalyticsObject'] = ga;      <span class="comment">// 向外暴露出ga对象</span>
    <span class="comment">// 确保只执行一次analytics.js的插入</span>
    <span class="keyword">win</span>[ga] = <span class="keyword">win</span>[ga] || function() {

        (<span class="keyword">win</span>[ga].q = <span class="keyword">win</span>[ga].q || []).push(arguments)},
        <span class="keyword">win</span>[ga].<span class="keyword">l</span> = 1 * new <span class="literal">Date</span>();         <span class="comment">// 把时间格式转换成数字型</span>

        <span class="comment">// 动态加载analytics.js</span>
        a = doc.createElement(o),
        <span class="keyword">m</span> = doc.getElementsByTagName(o)[0]; <span class="comment">// script</span>
        a.async = 1;
        a.src = <span class="keyword">g</span>;
        <span class="keyword">m</span>.parentNode.insertBefore(a, <span class="keyword">m</span>);
})(<span class="keyword">window</span>, document, 'script','<span class="comment">//www.google-analytics.com/analytics.js','ga');</span>
</code></pre><p>短短的代码, 还是蛮有货的，呵呵。   </p>
<h2 id="压缩的代码">压缩的代码</h2><pre><code><span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">i</span>,s,o,g,r,a,m)</span><span class="collection">{i<span class="collection">['GoogleAnalyticsObject']</span>=r;i<span class="collection">[r]</span>=i<span class="collection">[r]</span>||function<span class="list">()</span><span class="collection">{<span class="list">(<span class="keyword">i</span><span class="collection">[r]</span>.q=i<span class="collection">[r]</span>.q||<span class="collection">[]</span>)</span>.push<span class="list">(<span class="keyword">arguments</span>)</span>}</span>,i<span class="collection">[r]</span>.l=1*new Date<span class="list">()</span><span class="comment">;a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');</span></span></span>
</code></pre><p>参考: <a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/advanced?hl=zh-TW" target="_blank" rel="external">https://developers.google.com/analytics/devguides/collection/analyticsjs/advanced?hl=zh-TW</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="代码整理和注释">代码整理和注释</h2><pre><code><span class="comment">// 创建ga()方法, 加载analytics.js文件</span>
<span class="comment">// a, m 作为形参，确保下面的执]]>
    </summary>
    
      <category term="工具" scheme="http://mackxu.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS数组去重比较]]></title>
    <link href="http://mackxu.github.io/2014/07/21/array-unique/"/>
    <id>http://mackxu.github.io/2014/07/21/array-unique/</id>
    <published>2014-07-20T23:58:53.000Z</published>
    <updated>2014-08-29T11:14:07.000Z</updated>
    <content type="html"><![CDATA[<p>数组去重复是一个常见的需求，我们暂时考虑同类型的数组去重复。主要是理清思路和考虑执行性能。<br><a id="more"></a></p>
<h2 id="for循环删除后面重复的">for循环删除后面重复的</h2><pre><code><span class="keyword">var</span> uniqueFor = <span class="function"><span class="keyword">function</span><span class="params">(arr)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {
        <span class="keyword">var</span> item = arr[i];
        <span class="keyword">for</span>(<span class="keyword">var</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++ ) {
            item === arr[j] &amp;&amp; (arr.splice(j, <span class="number">1</span>), j--);
        }
    };
    <span class="keyword">return</span> arr;
};
</code></pre><h2 id="判断对象属性">判断对象属性</h2><pre><code><span class="keyword">var</span> uniqueObject = <span class="function"><span class="keyword">function</span><span class="params">(arr)</span> </span>{
    <span class="keyword">var</span> v, r = [], o = {};
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; (v = arr[i]) !== <span class="literal">undefined</span>; i++) {
        !o[v] &amp;&amp; (r.push(v), o[v] = <span class="literal">true</span>);
    }
    <span class="keyword">return</span> r;
};
</code></pre><h2 id="数组过滤重复项filter">数组过滤重复项filter</h2><pre><code><span class="keyword">var</span> uniqueFilter = <span class="function"><span class="keyword">function</span><span class="params">(arr)</span> </span>{
    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span><span class="params">(elem, pos, self)</span> </span>{
        <span class="comment">// 如果没有重复项，返回true</span>
        <span class="keyword">return</span> <span class="keyword">self</span>.indexOf(elem, pos + <span class="number">1</span>) === -<span class="number">1</span>;
    });
};
</code></pre><h2 id="比较执行效率">比较执行效率</h2><p><img src="http://qnimg.qiniudn.com/140721/chrome-unique.png" alt=""><strong>图1 chrome浏览器</strong></p>
<p><img src="http://qnimg.qiniudn.com/140721/ff-unique.png" alt=""><strong>图2 firefox浏览器</strong></p>
<p><img src="http://qnimg.qiniudn.com/140721/chrome-unique.png" alt=""><strong>图3 IE浏览器</strong></p>
<p><em>参考文献</em><br><a href="http://jsperf.com/quchong/5" target="_blank" rel="external">http://jsperf.com/quchong/5</a><br><a href="http://www.nowamagic.net/javascript/js_RemoveRepeatElement.php" target="_blank" rel="external">http://www.nowamagic.net/javascript/js_RemoveRepeatElement.php</a><br><a href="http://blog.segmentfault.com/fishenal/1190000000418858" target="_blank" rel="external">http://blog.segmentfault.com/fishenal/1190000000418858</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数组去重复是一个常见的需求，我们暂时考虑同类型的数组去重复。主要是理清思路和考虑执行性能。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://mackxu.github.io/tags/javascript/"/>
    
      <category term="性能优化" scheme="http://mackxu.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
